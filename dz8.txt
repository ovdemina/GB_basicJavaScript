Задание 1. Для практикума из занятия 7 продумать, где можно применить замыкания.

Думаю замыкания можно применить при разработке "телепортации" змейки - при пересечении границ заданного поля и продолжении движения с противоположной стороны.
Можно создать вложенную функцию, обеспечивающую процесс "телепортации" внутри функции move(), которая будет использовать координаты из move().

Задание 2. Не выполняя кода, ответить, что выведет браузер и почему:

Честно скажу, что запускала фрагменты, потому что хотелось узнать верность моих догадок, почти всегда не угадывала. Поэтому описываю мои догадки почему выводится такой результат.

if (!("a" in window)) {
var a = 1;
}
alert(a);
Результат: undefined
Я неимоверное количество времени пыталась разобрать что значит это выражение ("a" in window). До конца так и не поняла, в общем думаю так: 
window - (как Вы говорили) это глобальный объект - все окно браузера. У него есть свои свойства и методы.
Так вот это выражение проверяет, есть ли метод, свойство "а" в объекте window?
Тогда среди этого списка (выводила window в консоль) window.а нет. 
Тогда получается, что выражение ложно, а (!("a" in window)) - истинно, значит должно выполняться var a = 1 и выводиться на экран 1.
(т.к. var имеет видимость неблочную, в отличие от let). НО ЭТО НЕ ТАК.

Или оно добавляет "a" в объект (в общем что бы не значило это выражение, условие не выполняется)?
Тогда "a" in window заведомо истинное выражение, и !("a" in window) будет ложным, var a = 1 - выполняться не будет
Значит будет выведено глобальное значение a, а его не определяли, поэтому получаем "undefined". 
Если бы ранее a было присвоено какое-либо значение, то было бы выведено оно.


var b = function a(x) {
    x && a(--x);
};
alert(a);
Результат: ничего
Здесь функция присвоена переменной b, значит после слова function должны следовать аргументы. 
А здесь наверно атрибутом является некая необъявленная функция a(x). Поэтому ничего не происходит. Если ее определить, по идее должна быть выведена эта функция.


function a(x) {
    return x * 2;
}
var a;
alert(a);
Результат: function a(x) {   return x * 2; }
По логике предыдущего примера здесь мы как раз определили ту самую функцию a(x), и вывели ее содержимое. 
Строка "var a" по моему не играет роли, оно же в данном случае не переопределяет значение.



function b(x, y, a) {
    arguments[2] = 10;
    alert(a);
}
b(1, 2, 3);
Результат: 10
Выводим значение третьего аргумента, которому приваивается значение 10.



function a() {
    alert(this);
}
a.call(null);
Результат: [object Window]
С помощью метода call() мы вызываем функцию a(), аргумент null - наверно означает отсутствие аргументов, не вижу разницы с "a.call()". 
this - это объект, который запускает функцию, мы хотим вывести его на экран. Но без аргументов нет конкретного объекта, поэтому вызывает функцию глобальный объект "window".